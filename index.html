<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>äº‘ç«¯å¤©å®« CloudTower 3D - Enhanced</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; background: #000; }
        #canvas-container { width: 100vw; height: 100vh; }
        #info {
            position: absolute; top: 10px; left: 10px;
            background: rgba(0,0,0,0.7); padding: 15px; border-radius: 10px;
            font-family: 'Microsoft YaHei', sans-serif; font-size: 14px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            max-width: 300px; color: white;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
        }
        #info h1 { color: #00CED1; font-size: 20px; margin-bottom: 10px; text-shadow: 0 0 10px rgba(0,206,209,0.5); }
        #info .zone { color: #ccc; margin: 5px 0; padding: 5px; background: rgba(255,255,255,0.1); border-radius: 5px; font-size: 12px; }
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 24px; color: #00CED1; font-family: 'Microsoft YaHei', sans-serif;
            text-shadow: 0 0 20px rgba(0,206,209,0.8);
        }
        #progress { margin-top: 10px; font-size: 14px; color: #888; }
    </style>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>
</head>
<body>
    <div id="canvas-container"></div>
    <div id="info">
        <h1>ğŸ¯ äº‘ç«¯å¤©å®« Enhanced</h1>
        <p style="color: #888; font-size: 12px; margin-bottom: 10px;">CloudTower - PBRæè´¨ç‰ˆ</p>
        <div class="zone">ğŸ¯ ZONE 2: å¯è§‚æµ‹æ€§å¹³å°</div>
        <div class="zone">ğŸ” ZONE 3: å…¨å±€æœç´¢</div>
        <div class="zone">ğŸ“‹ ZONE 4: ä»»åŠ¡ä¸­å¿ƒ</div>
        <p style="margin-top: 10px; font-size: 11px; color: #666;">
            é¼ æ ‡æ‹–æ‹½æ—‹è½¬ | æ»šè½®ç¼©æ”¾
        </p>
    </div>
    <div id="loading">
        æ­£åœ¨åŠ è½½å¤©å®«èµ„æº...
        <div id="progress">0%</div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';

        // åœºæ™¯åˆå§‹åŒ–
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050510);
        scene.fog = new THREE.FogExp2(0x050510, 0.015);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 25, 50);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // åå¤„ç†
        const composer = new EffectComposer(renderer);
        const renderPass = new RenderPass(scene, camera);
        composer.addPass(renderPass);

        const bloomPass = new UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight),
            0.8, 0.5, 0.85
        );
        composer.addPass(bloomPass);

        // æ§åˆ¶å™¨
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.maxPolarAngle = Math.PI / 2 - 0.05;
        controls.minDistance = 15;
        controls.maxDistance = 100;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.5;

        // åŠ è½½ç®¡ç†å™¨
        const loadingManager = new THREE.LoadingManager();
        const loadingElement = document.getElementById('loading');
        const progressElement = document.getElementById('progress');

        loadingManager.onProgress = (url, loaded, total) => {
            const progress = Math.round((loaded / total) * 100);
            progressElement.textContent = `${progress}%`;
        };

        loadingManager.onLoad = () => {
            loadingElement.style.display = 'none';
        };

        // HDR ç¯å¢ƒè´´å›¾åŠ è½½
        const rgbeLoader = new RGBELoader(loadingManager);
        rgbeLoader.setPath('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/equirectangular/');
        
        rgbeLoader.load('royal_esplanade_1k.hdr', (texture) => {
            texture.mapping = THREE.EquirectangularReflectionMapping;
            scene.environment = texture;
            scene.background = texture;
            scene.backgroundBlurriness = 0.5;
        }, undefined, (error) => {
            // HDR åŠ è½½å¤±è´¥æ—¶ä½¿ç”¨å¤‡ç”¨æ–¹æ¡ˆ
            console.log('HDRåŠ è½½å¤±è´¥ï¼Œä½¿ç”¨ç¨‹åºåŒ–ç¯å¢ƒ');
            createProceduralEnvironment();
        });

        // ç¨‹åºåŒ–ç¯å¢ƒå¤‡ç”¨æ–¹æ¡ˆ
        function createProceduralEnvironment() {
            const pmremGenerator = new THREE.PMREMGenerator(renderer);
            pmremGenerator.compileEquirectangularShader();
            
            const gradientTexture = new THREE.CanvasTexture(createGradientCanvas());
            gradientTexture.mapping = THREE.EquirectangularReflectionMapping;
            scene.environment = gradientTexture;
        }

        function createGradientCanvas() {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createLinearGradient(0, 0, 0, 256);
            gradient.addColorStop(0, '#1a1a3e');
            gradient.addColorStop(0.5, '#2d1b4e');
            gradient.addColorStop(1, '#0f0f23');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 512, 256);
            return canvas;
        }

        // é«˜çº§æè´¨å®šä¹‰
        const jadeMaterial = new THREE.MeshPhysicalMaterial({
            color: 0x2E8B57,
            metalness: 0.2,
            roughness: 0.1,
            transmission: 0.3,
            thickness: 1.5,
            clearcoat: 1,
            clearcoatRoughness: 0.1,
            envMapIntensity: 1.5
        });

        const goldMaterial = new THREE.MeshPhysicalMaterial({
            color: 0xFFD700,
            metalness: 1.0,
            roughness: 0.15,
            clearcoat: 1,
            clearcoatRoughness: 0.1,
            envMapIntensity: 2.0
        });

        const crystalMaterial = new THREE.MeshPhysicalMaterial({
            color: 0x00CED1,
            metalness: 0.1,
            roughness: 0,
            transmission: 0.95,
            thickness: 3,
            ior: 1.5,
            emissive: 0x00CED1,
            emissiveIntensity: 0.5,
            envMapIntensity: 2.0
        });

        // å…‰ç…§ç³»ç»Ÿ
        const ambientLight = new THREE.AmbientLight(0x404080, 0.5);
        scene.add(ambientLight);

        const moonLight = new THREE.DirectionalLight(0xaaccff, 1.0);
        moonLight.position.set(50, 100, 50);
        moonLight.castShadow = true;
        moonLight.shadow.mapSize.width = 4096;
        moonLight.shadow.mapSize.height = 4096;
        moonLight.shadow.camera.near = 0.5;
        moonLight.shadow.camera.far = 500;
        moonLight.shadow.bias = -0.001;
        scene.add(moonLight);

        const fillLight = new THREE.DirectionalLight(0xffaa00, 0.3);
        fillLight.position.set(-50, 20, -50);
        scene.add(fillLight);

        // ç‚¹å…‰æºï¼ˆå®«æ®¿ç…§æ˜ï¼‰
        const palaceLight = new THREE.PointLight(0x00CED1, 2, 30);
        palaceLight.position.set(0, 15, 0);
        scene.add(palaceLight);

        // åˆ›å»ºäº‘æœµå¹³å°
        function createCloudPlatform(x, y, z, scale = 1) {
            const group = new THREE.Group();
            
            const cloudGeometry = new THREE.SphereGeometry(10 * scale, 64, 64);
            const cloudMaterial = new THREE.MeshPhysicalMaterial({
                color: 0xffffff,
                metalness: 0,
                roughness: 0.8,
                transmission: 0.1,
                transparent: true,
                opacity: 0.9
            });
            
            const mainCloud = new THREE.Mesh(cloudGeometry, cloudMaterial);
            mainCloud.scale.y = 0.25;
            mainCloud.position.y = -2;
            mainCloud.castShadow = true;
            mainCloud.receiveShadow = true;
            group.add(mainCloud);

            // æ·»åŠ å¤šä¸ªå°äº‘æœµ
            for (let i = 0; i < 8; i++) {
                const smallCloud = new THREE.Mesh(
                    new THREE.SphereGeometry(3 * scale, 32, 32),
                    cloudMaterial
                );
                const angle = (i / 8) * Math.PI * 2;
                const radius = 8 * scale;
                smallCloud.position.set(
                    Math.cos(angle) * radius,
                    -1 + Math.random() * 2,
                    Math.sin(angle) * radius
                );
                smallCloud.scale.y = 0.4 + Math.random() * 0.3;
                group.add(smallCloud);
            }

            group.position.set(x, y, z);
            scene.add(group);
            return group;
        }

        // åˆ›å»ºç²¾ç»†ä¸»æ®¿ (ZONE 2)
        function createMainHall() {
            const group = new THREE.Group();

            // å¤šå±‚åº•åº§
            for (let i = 0; i < 3; i++) {
                const base = new THREE.Mesh(
                    new THREE.CylinderGeometry(14 - i * 2, 16 - i * 2, 1.5, 8),
                    jadeMaterial
                );
                base.position.y = i * 1.5 + 0.75;
                base.receiveShadow = true;
                group.add(base);
            }

            // ä¸»æ®¿å»ºç­‘ - åˆ†æ®µå¼
            const hallLevels = [
                { width: 14, height: 8, y: 6 },
                { width: 11, height: 6, y: 13 },
                { width: 8, height: 4, y: 18 }
            ];

            hallLevels.forEach((level, index) => {
                const hall = new THREE.Mesh(
                    new THREE.BoxGeometry(level.width, level.height, level.width * 0.7),
                    jadeMaterial
                );
                hall.position.y = level.y;
                hall.castShadow = true;
                group.add(hall);

                // å±‹æª
                const roof = new THREE.Mesh(
                    new THREE.ConeGeometry(level.width * 0.9, 3, 4),
                    goldMaterial
                );
                roof.position.y = level.y + level.height / 2 + 1.5;
                roof.rotation.y = Math.PI / 4;
                group.add(roof);

                // æŸ±å­
                if (index === 0) {
                    for (let i = 0; i < 4; i++) {
                        const pillar = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.6, 0.8, level.height, 12),
                            goldMaterial
                        );
                        const angle = (i / 4) * Math.PI * 2;
                        pillar.position.set(
                            Math.cos(angle) * level.width * 0.35,
                            level.y,
                            Math.sin(angle) * level.width * 0.25
                        );
                        pillar.castShadow = true;
                        group.add(pillar);
                    }
                }
            });

            // ä¸­å¤®æ°´æ™¶çƒï¼ˆé«˜çº§ç‰ˆï¼‰
            const sphereGroup = new THREE.Group();
            
            const crystal = new THREE.Mesh(
                new THREE.SphereGeometry(3, 64, 64),
                crystalMaterial
            );
            sphereGroup.add(crystal);

            // å¤šå±‚ç¯ç»•ç¯
            [4, 5.5, 7].forEach((radius, index) => {
                const ring = new THREE.Mesh(
                    new THREE.TorusGeometry(radius, 0.08, 12, 64),
                    goldMaterial
                );
                ring.rotation.x = Math.PI / 2 + index * 0.3;
                ring.rotation.y = index * 0.5;
                sphereGroup.add(ring);
            });

            sphereGroup.position.y = 6;
            group.add(sphereGroup);

            // å†…éƒ¨å‘å…‰æ ¸å¿ƒ
            const core = new THREE.Mesh(
                new THREE.SphereGeometry(1.5, 32, 32),
                new THREE.MeshBasicMaterial({
                    color: 0x00ffff,
                    transparent: true,
                    opacity: 0.8
                })
            );
            core.position.y = 6;
            group.add(core);

            group.userData = { crystal: sphereGroup, core: core };
            return group;
        }

        // åˆ›å»ºé«˜å¡” (ZONE 3 å’Œ ZONE 6)
        function createTower(x, z, height = 35, hasBeam = false) {
            const group = new THREE.Group();

            // å¡”èº«åˆ†æ®µ - æ›´ç²¾ç»†
            const levels = 7;
            for (let i = 0; i < levels; i++) {
                const progress = i / levels;
                const width = 7 * (1 - progress * 0.6);
                const levelHeight = height / levels;
                
                const level = new THREE.Mesh(
                    new THREE.BoxGeometry(width, levelHeight, width),
                    jadeMaterial
                );
                level.position.y = i * levelHeight + levelHeight / 2 + 3;
                level.castShadow = true;
                group.add(level);

                // ç²¾è‡´çš„å±‹æª
                const eave = new THREE.Mesh(
                    new THREE.ConeGeometry(width * 0.85, 2, 4),
                    goldMaterial
                );
                eave.position.y = (i + 1) * levelHeight + 3;
                eave.rotation.y = Math.PI / 4;
                group.add(eave);

                // çª—æˆ·
                if (i % 2 === 0) {
                    for (let j = 0; j < 4; j++) {
                        const window = new THREE.Mesh(
                            new THREE.BoxGeometry(0.8, 1.5, 0.2),
                            new THREE.MeshBasicMaterial({ 
                                color: 0xffaa00,
                                emissive: 0xff6600,
                                emissiveIntensity: 0.5
                            })
                        );
                        const angle = (j / 4) * Math.PI * 2;
                        window.position.set(
                            Math.cos(angle) * width * 0.51,
                            i * levelHeight + levelHeight / 2 + 3,
                            Math.sin(angle) * width * 0.51
                        );
                        window.lookAt(0, window.position.y, 0);
                        group.add(window);
                    }
                }
            }

            // å¡”å°–
            const spire = new THREE.Mesh(
                new THREE.ConeGeometry(1, 6, 8),
                goldMaterial
            );
            spire.position.y = height + 6;
            group.add(spire);

            // å…‰æŸæ•ˆæœ (ZONE 3)
            if (hasBeam) {
                const beamGeometry = new THREE.CylinderGeometry(0.3, 1.5, 50, 16, 1, true);
                const beamMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        color: { value: new THREE.Color(0x00CED1) }
                    },
                    vertexShader: `
                        varying vec2 vUv;
                        void main() {
                            vUv = uv;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform float time;
                        uniform vec3 color;
                        varying vec2 vUv;
                        void main() {
                            float alpha = 0.3 * (1.0 - vUv.y) * (0.5 + 0.5 * sin(time * 3.0 + vUv.y * 10.0));
                            gl_FragColor = vec4(color, alpha);
                        }
                    `,
                    transparent: true,
                    side: THREE.DoubleSide,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                const beam = new THREE.Mesh(beamGeometry, beamMaterial);
                beam.position.y = height + 25;
                group.add(beam);
                group.userData = { beam: beam, beamMaterial: beamMaterial };
            }

            group.position.set(x, 0, z);
            return group;
        }

        // åˆ›å»ºæµå…‰ä¼ é€å¸¦ (ZONE 4) - å¢å¼ºç‰ˆ
        function createTaskConveyor() {
            const group = new THREE.Group();
            
            // Så½¢è·¯å¾„
            const curve = new THREE.CatmullRomCurve3([
                new THREE.Vector3(-18, 2, 18),
                new THREE.Vector3(-8, 2, 23),
                new THREE.Vector3(0, 2, 18),
                new THREE.Vector3(8, 2, 23),
                new THREE.Vector3(18, 2, 18)
            ]);

            // æµå…‰è½¨é“ - ä½¿ç”¨ TubeGeometry
            const tubeGeometry = new THREE.TubeGeometry(curve, 100, 0.8, 16, false);
            const tubeMaterial = new THREE.MeshPhysicalMaterial({
                color: 0x40E0D0,
                metalness: 0.8,
                roughness: 0.1,
                transmission: 0.6,
                thickness: 1,
                emissive: 0x40E0D0,
                emissiveIntensity: 0.3,
                clearcoat: 1
            });
            const tube = new THREE.Mesh(tubeGeometry, tubeMaterial);
            group.add(tube);

            // æµåŠ¨ç²’å­ç³»ç»Ÿ
            const particleCount = 30;
            const particles = [];
            const particleGeometry = new THREE.SphereGeometry(0.3, 16, 16);
            const particleMaterial = new THREE.MeshBasicMaterial({
                color: 0xFFD700,
                emissive: 0xFF6600,
                emissiveIntensity: 1
            });

            for (let i = 0; i < particleCount; i++) {
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                const t = i / particleCount;
                const pos = curve.getPoint(t);
                particle.position.copy(pos);
                particle.userData = { 
                    t: t, 
                    curve: curve,
                    speed: 0.001 + Math.random() * 0.001
                };
                group.add(particle);
                particles.push(particle);
            }

            group.userData = { particles: particles };
            return group;
        }

        // åˆ›å»ºç‰ŒåŠå…¥å£ (ZONE 1) - å¢å¼ºç‰ˆ
        function createEntrance() {
            const group = new THREE.Group();

            // æŸ±å­ - æ›´ç²¾ç»†
            const createPillar = (x) => {
                const pillar = new THREE.Group();
                
                // æŸ±èº«
                const shaft = new THREE.Mesh(
                    new THREE.CylinderGeometry(1.2, 1.4, 10, 12),
                    jadeMaterial
                );
                shaft.position.y = 5;
                shaft.castShadow = true;
                pillar.add(shaft);
                
                // æŸ±å¤´è£…é¥°
                const capital = new THREE.Mesh(
                    new THREE.CylinderGeometry(1.6, 1.2, 1.5, 8),
                    goldMaterial
                );
                capital.position.y = 10.75;
                pillar.add(capital);
                
                // æŸ±ç¡€
                const base = new THREE.Mesh(
                    new THREE.CylinderGeometry(1.8, 2, 1, 8),
                    jadeMaterial
                );
                base.position.y = 0.5;
                pillar.add(base);
                
                pillar.position.x = x;
                return pillar;
            };

            group.add(createPillar(-8));
            group.add(createPillar(8));

            // æ¨ªæ¢ - åŒå±‚
            const mainBeam = new THREE.Mesh(
                new THREE.BoxGeometry(20, 2.5, 2.5),
                goldMaterial
            );
            mainBeam.position.set(0, 11.5, 0);
            group.add(mainBeam);

            const topBeam = new THREE.Mesh(
                new THREE.BoxGeometry(18, 1.5, 2),
                jadeMaterial
            );
            topBeam.position.set(0, 14, 0);
            group.add(topBeam);

            // å±‹é¡¶ - æ›´å¤æ‚
            const roof = new THREE.Mesh(
                new THREE.ConeGeometry(12, 4, 4),
                goldMaterial
            );
            roof.position.set(0, 16.5, 0);
            roof.rotation.y = Math.PI / 4;
            roof.scale.z = 0.6;
            group.add(roof);

            // çŸ³ç‹®å­ - æ›´ç²¾ç»†
            const createLion = (x) => {
                const lion = new THREE.Group();
                
                // èº«ä½“
                const body = new THREE.Mesh(
                    new THREE.BoxGeometry(2, 2.5, 3),
                    new THREE.MeshStandardMaterial({ 
                        color: 0x8B7355,
                        roughness: 0.8
                    })
                );
                body.position.y = 1.25;
                lion.add(body);
                
                // å¤´éƒ¨
                const head = new THREE.Mesh(
                    new THREE.BoxGeometry(1.8, 1.5, 1.8),
                    new THREE.MeshStandardMaterial({ 
                        color: 0x8B7355,
                        roughness: 0.8
                    })
                );
                head.position.set(0, 3, 1);
                lion.add(head);
                
                // åº•åº§
                const pedestal = new THREE.Mesh(
                    new THREE.BoxGeometry(2.5, 0.8, 3.5),
                    jadeMaterial
                );
                pedestal.position.y = 0.4;
                lion.add(pedestal);
                
                lion.position.set(x, 0, 5);
                return lion;
            };

            group.add(createLion(-10));
            group.add(createLion(10));

            group.position.set(0, 0, 35);
            return group;
        }

        // åˆ›å»ºé«˜çº§ç²’å­ç³»ç»Ÿ
        function createParticleSystem() {
            const geometry = new THREE.BufferGeometry();
            const count = 1000;
            const positions = new Float32Array(count * 3);
            const colors = new Float32Array(count * 3);
            const sizes = new Float32Array(count);

            const color1 = new THREE.Color(0xFFD700);
            const color2 = new THREE.Color(0x00CED1);

            for (let i = 0; i < count; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 150;
                positions[i * 3 + 1] = Math.random() * 60;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 150;

                const mixRatio = Math.random();
                const color = color1.clone().lerp(color2, mixRatio);
                colors[i * 3] = color.r;
                colors[i * 3 + 1] = color.g;
                colors[i * 3 + 2] = color.b;

                sizes[i] = Math.random() * 2 + 0.5;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            const material = new THREE.PointsMaterial({
                size: 1,
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true
            });

            const particles = new THREE.Points(geometry, material);
            particles.userData = { 
                initialY: positions.slice(),
                speeds: Array(count).fill(0).map(() => Math.random() * 0.03 + 0.01)
            };
            return particles;
        }

        // æ„å»ºåœºæ™¯
        const cloudPlatform = createCloudPlatform(0, -8, 0, 4);
        const mainHall = createMainHall();
        const searchTower = createTower(-30, -15, 40, true);
        const upgradeTower = createTower(30, -20, 35, false);
        const taskConveyor = createTaskConveyor();
        const entrance = createEntrance();
        const particles = createParticleSystem();

        scene.add(mainHall);
        scene.add(searchTower);
        scene.add(upgradeTower);
        scene.add(taskConveyor);
        scene.add(entrance);
        scene.add(particles);

        // åŠ¨ç”»å¾ªç¯
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            const time = clock.getElapsedTime();

            // æ—‹è½¬æ°´æ™¶çƒå’Œå†…éƒ¨æ ¸å¿ƒ
            if (mainHall.userData.crystal) {
                mainHall.userData.crystal.rotation.y = time * 0.3;
                mainHall.userData.crystal.rotation.x = Math.sin(time * 0.2) * 0.1;
            }
            if (mainHall.userData.core) {
                mainHall.userData.core.scale.setScalar(1 + Math.sin(time * 2) * 0.1);
            }

            // è„‰å†²å…‰æŸç€è‰²å™¨
            if (searchTower.userData.beamMaterial) {
                searchTower.userData.beamMaterial.uniforms.time.value = time;
            }

            // æµåŠ¨ä»»åŠ¡ç²’å­
            if (taskConveyor.userData.particles) {
                taskConveyor.userData.particles.forEach(particle => {
                    particle.userData.t += particle.userData.speed;
                    if (particle.userData.t > 1) particle.userData.t = 0;
                    const pos = particle.userData.curve.getPoint(particle.userData.t);
                    particle.position.copy(pos);
                    particle.rotation.x += 0.03;
                    particle.rotation.y += 0.03;
                });
            }

            // æ¼‚æµ®ç²’å­
            const positions = particles.geometry.attributes.position.array;
            const initialY = particles.userData.initialY;
            const speeds = particles.userData.speeds;
            for (let i = 0; i < 1000; i++) {
                positions[i * 3 + 1] = initialY[i * 3 + 1] + Math.sin(time * speeds[i] + i) * 5;
            }
            particles.geometry.attributes.position.needsUpdate = true;
            particles.rotation.y = time * 0.02;

            controls.update();
            composer.render();
        }

        animate();

        // çª—å£å¤§å°è°ƒæ•´
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        // ç‚¹å‡»äº¤äº’
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        window.addEventListener('click', (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(scene.children, true);

            if (intersects.length > 0) {
                // ç®€å•çš„ç‚¹å‡»åé¦ˆ
                const obj = intersects[0].object;
                if (obj.material && obj.material.emissive) {
                    const originalEmissive = obj.material.emissive.clone();
                    obj.material.emissive.setHex(0xffffff);
                    setTimeout(() => {
                        obj.material.emissive.copy(originalEmissive);
                    }, 200);
                }
            }
        });
    </script>
</body>
</html>
